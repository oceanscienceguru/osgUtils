#' Parse goto_l*.ma files
#'
#' Dynamically parse glider goto files
#' and pull out useful variables.
#'
#' @param inFile user-specified path to file
#' @return dataframe of waypoints and associated metadata
#' @export

gotoLoad <- function(inFile){
    rawMa <- utils::read.delim(inFile, sep = "\n")
    rawMa <- as.data.frame(rawMa)
    colnames(rawMa)[1] = "raw"

    #get row indices for waypoint list block
    first <- which(stringr::str_starts(stringr::str_trim(rawMa$raw), "<start:waypoints>"))
    last  <- which(stringr::str_starts(stringr::str_trim(rawMa$raw), "<end:waypoints>"))

    #find radius
    radInd <- which(stringr::str_detect(rawMa$raw, "b_arg: list_when_wpt_dist"))
    radBarg <- rawMa[radInd,1]
    rads <- ifelse(stringr::str_detect(radBarg, ".*(?=#)"),stringr::str_extract(radBarg, ".*(?=#)"), radBarg) %>% #strip off any comments at end
      stringr::str_trim() %>%
      readr::parse_number()

    wptsRaw <- rawMa %>%
      dplyr::slice((first+1):(last-1)) %>% #pull out all the wpts
      dplyr::filter(!stringr::str_starts(raw,"#")) %>% #remove any commented lines
      dplyr::mutate(nums = ifelse(stringr::str_detect(raw, ".*(?=#)"),stringr::str_extract(raw, ".*(?=#)"), raw)) %>% #strip off any comments at end
      dplyr::mutate(comment = stringr::str_trim(ifelse(stringr::str_detect(raw, "(?=#).*"),stringr::str_extract(raw, "(?=#).*"), ""))) %>% #extract any comments from end
      dplyr::mutate(cleanNums = stringr::str_trim(.data$nums)) %>% #clean up both sides
      tidyr::separate_wider_delim("cleanNums", delim = stringr::regex("\\s+"), names = c("rawlong", "rawlat"), too_many = "merge") %>% #break into 2
      #convert to decimal degrees using osg function
      dplyr::mutate(lat = gliderGPS_to_dd(.data$rawlat),
                    long = gliderGPS_to_dd(.data$rawlong)) %>%
      dplyr::mutate(rad = ifelse(!rlang::is_empty(rads), rads, 10)) %>% # pull in parsed radius if present. otherwise masterdata default
      dplyr::mutate(order = dplyr::row_number()) #get order of wpts as listed

    return(wptsRaw)
  }

#' Convert ssv generated by dbd2asc into dataframe
#'
#' Builds dataframe from standard ssv generated
#' by dbd2asc on any format of glider data
#'
#' @param inputFile user-specified path to file
#' @param headerSize number of lines to consider as "header"
#' @return dataframe of ssv minus the header
#' @export
ssv_to_df <- function(inputFile, headerSize = 14) {
    top <- utils::read.csv(inputFile,
                    sep="", #whitespace as delimiter
                    nrows=headerSize
    )

    head <- utils::read.csv(inputFile,
                     sep="", #whitespace as delimiter
                     skip=headerSize,
                     nrows=1,
                     header = TRUE)

    units <- utils::read.csv(inputFile,
                      sep="", #whitespace as delimiter
                      skip=headerSize,
                      nrows=1,
                      header = TRUE)

    raw <- utils::read.csv(inputFile,
                    sep="", #whitespace as delimiter
                    skip=headerSize,
                    header = TRUE)

    vars <- colnames(head)
    N <- 2
    raw <- utils::tail(raw, -N)

    newGlider <- raw %>%
      dplyr::mutate(dplyr::across(tidyr::everything(), ~ as.numeric(.)))

    if ("m_present_time" %in% vars){
      newGlider$m_present_time <- lubridate::as_datetime(newGlider$m_present_time) #convert to POSIXct
      if (nrow(newGlider) > 0){
        newGlider$m_present_time <- lubridate::as_datetime(floor(lubridate::seconds(newGlider$m_present_time))) #round to seconds
      }
    } else if ("sci_m_present_time" %in% vars){
      newGlider$sci_m_present_time <- lubridate::as_datetime(newGlider$sci_m_present_time) #convert to POSIXct
      if (nrow(newGlider) > 0){
        newGlider$sci_m_present_time <- lubridate::as_datetime(floor(lubridate::seconds(newGlider$sci_m_present_time))) #round to seconds
      }

    }

    return(newGlider)
  }
